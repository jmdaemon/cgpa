use std::{error::Error, io};

use csv::{ReaderBuilder, Trim};
use gpa::{create_csv_reader, read_gpa_scale, Grade, GradeScale};
use serde::{de::{self, Visitor}, Deserialize, Deserializer};

fn main() -> Result<(), Box<dyn Error>> {
    
    // Read the specific gpa scaling
    // Letter, Grade Point, Conversion
    let lines = vec!(
        "A+, 4.33, 90,100",
        "A , 4.00, 85,89",
        "A-, 3.67, 80,84",
        "B+, 3.33, 76,79",
        "B , 3.00, 72,75",
        "B-, 2.67, 68,71",
        "C+, 2.33, 64,67",
        "C , 2.00, 60,63",
        "C-, 1.67, 56,59",
        "D , 1.00, 50,55",
        "F , 0.00,  0,49",
    ).into_iter().map(String::from).collect::<Vec<String>>();

    let lines = lines.join("\n");

    let mut rdr = create_csv_reader(lines.as_bytes());
    for result in rdr.deserialize() {
        let record: Grade = result?;
        println!("{:?}", record);
    }
    let scale = read_gpa_scale(rdr);

    // Now we need to parse our actual course data
    // Parse a line in a csv file like
    // let data = "
    // ";
    // println!("Hello, world!");
    let lines= vec!(
        "3 Quizzes   , 10%",
        "2 Projects  , 20%",
        "5 Labs      , 20%",
        "Midterm Exam, 20%",
        "Final Exam  , 30%",
    );

    let lines = lines.join("\n");

    let mut rdr = 
        ReaderBuilder::new()
            .has_headers(false)
            .trim(Trim::All)
            .from_reader(lines.as_bytes());

    for result in rdr.deserialize() {
        let record: Grade = result?;
        println!("{:?}", record);
    }

    Ok(())
}

// To calculate a gpa we have a list of 

struct Percent {
    percent: String,
    // weight: f64,
    weight: u8,
}

struct PercentVisitor;
impl<'de> Visitor<'de> for PercentVisitor {
    type Value = Percent;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a whole number percent between 0-100 (e.g 55%)")
    }

    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
        where
            E: de::Error, {
                let a = v.as_bytes();
                let s = (a[0] + a[1]).to_string();
                let num = s.parse::<u8>().expect("Could not parse string");
                Ok(Percent { percent: v.to_owned(), weight: num })
                // Ok(s.parse::<u8>().expect("Could not parse string"))
    }

    fn visit_i32<E>(self, value: i32) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        let percent = value.to_string() + '%'; 
        Ok(Percent { percent: v.to_owned(), weight: num })
        // Ok(value as u8)
    }
}

// impl<'de> Deserialize<'de> for Percent {
impl<'de> Deserialize<'de> for Percent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: Deserializer<'de> {
        deserializer.deserialize_str(PercentVisitor)
    }
}

struct Grading {
    title: String,
    // #[serde(deserialize_with = "deserialize_percent")]
    // weight: f64,
}

// fn read_percent<'de, D>(D) -> Result<T, D::Error> where D: Deserializer<'de> {
// fn read_percent<D>(deserializer: D) -> Result<f64, D::Error> {
// }
// fn deserialize_percent<'de, D>(d: D) -> Result<f64, D::Error> where D: Deserializer<'de> {
//     d.deserialize_str();
//     Ok(0.00f64)
// }


pub mod gpa {
    use std::ops::Range;

    use csv::{Reader, ReaderBuilder, Trim};
    use serde::{Deserialize, Serialize};

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Grade {
        letter: String,
        grade_point: f64,
        // conversion: Range<(u8, u8)>,
        conversion: Range<u8>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct GradeScale {
        scale: Vec<Grade>,
    }

    pub type GradeScaleReader<'a> = Reader<&'a [u8]>;

    pub fn create_csv_reader(content: &[u8]) -> GradeScaleReader {
        ReaderBuilder::new()
            .has_headers(false)
            .trim(Trim::All)
            .from_reader(content)
    }

    pub fn read_gpa_scale(mut rdr: GradeScaleReader) -> GradeScale {
        let scale = rdr.deserialize()
            .into_iter()
            .flat_map(Result::ok)
            .collect();
        GradeScale { scale }
    }
}
